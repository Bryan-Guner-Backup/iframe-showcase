<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="minipass">minipass</h1>
<p>A <em>very</em> minimal implementation of a <a href="https://nodejs.org/api/stream.html#stream_class_stream_passthrough">PassThrough stream</a></p>
<p><a href="https://docs.google.com/spreadsheets/d/1oObKSrVwLX_7Ut4Z6g3fZW-AX1j1-k6w-cDsrkaSbHM/edit#gid=0">It’s very fast</a> for objects, strings, and buffers.</p>
<p>Supports pipe()ing (including multi-pipe() and backpressure transmission), buffering data until either a <code>data</code> event handler or <code>pipe()</code> is added (so you don’t lose the first chunk), and most other cases where PassThrough is a good idea.</p>
<p>There is a <code>read()</code> method, but it’s much more efficient to consume data from this stream via <code>'data'</code> events or by calling <code>pipe()</code> into some other stream. Calling <code>read()</code> requires the buffer to be flattened in some cases, which requires copying memory.</p>
<p>There is also no <code>unpipe()</code> method. Once you start piping, there is no stopping it!</p>
<p>If you set <code>objectMode: true</code> in the options, then whatever is written will be emitted. Otherwise, it’ll do a minimal amount of Buffer copying to ensure proper Streams semantics when <code>read(n)</code> is called.</p>
<p><code>objectMode</code> can also be set by doing <code>stream.objectMode = true</code>, or by writing any non-string/non-buffer data. <code>objectMode</code> cannot be set to false once it is set.</p>
<p>This is not a <code>through</code> or <code>through2</code> stream. It doesn’t transform the data, it just passes it right through. If you want to transform the data, extend the class, and override the <code>write()</code> method. Once you’re done transforming the data however you want, call <code>super.write()</code> with the transform output.</p>
<p>For some examples of streams that extend Minipass in various ways, check out:</p>
<ul>
<li><a href="http://npm.im/minizlib">minizlib</a></li>
<li><a href="http://npm.im/fs-minipass">fs-minipass</a></li>
<li><a href="http://npm.im/tar">tar</a></li>
<li><a href="http://npm.im/minipass-collect">minipass-collect</a></li>
<li><a href="http://npm.im/minipass-flush">minipass-flush</a></li>
<li><a href="http://npm.im/minipass-pipeline">minipass-pipeline</a></li>
<li><a href="http://npm.im/tap">tap</a></li>
<li><a href="http://npm.im/tap">tap-parser</a></li>
<li><a href="http://npm.im/tap">treport</a></li>
</ul>
<h2 id="differences-from-node.js-streams">Differences from Node.js Streams</h2>
<p>There are several things that make Minipass streams different from (and in some ways superior to) Node.js core streams.</p>
<p>Please read these caveats if you are familiar with noode-core streams and intend to use Minipass streams in your programs.</p>
<h3 id="timing">Timing</h3>
<p>Minipass streams are designed to support synchronous use-cases. Thus, data is emitted as soon as it is available, always. It is buffered until read, but no longer. Another way to look at it is that Minipass streams are exactly as synchronous as the logic that writes into them.</p>
<p>This can be surprising if your code relies on <code>PassThrough.write()</code> always providing data on the next tick rather than the current one, or being able to call <code>resume()</code> and not have the entire buffer disappear immediately.</p>
<p>However, without this synchronicity guarantee, there would be no way for Minipass to achieve the speeds it does, or support the synchronous use cases that it does. Simply put, waiting takes time.</p>
<p>This non-deferring approach makes Minipass streams much easier to reason about, especially in the context of Promises and other flow-control mechanisms.</p>
<h3 id="no-highlow-water-marks">No High/Low Water Marks</h3>
<p>Node.js core streams will optimistically fill up a buffer, returning <code>true</code> on all writes until the limit is hit, even if the data has nowhere to go. Then, they will not attempt to draw more data in until the buffer size dips below a minimum value.</p>
<p>Minipass streams are much simpler. The <code>write()</code> method will return <code>true</code> if the data has somewhere to go (which is to say, given the timing guarantees, that the data is already there by the time <code>write()</code> returns).</p>
<p>If the data has nowhere to go, then <code>write()</code> returns false, and the data sits in a buffer, to be drained out immediately as soon as anyone consumes it.</p>
<h3 id="hazards-of-buffering-or-why-minipass-is-so-fast">Hazards of Buffering (or: Why Minipass Is So Fast)</h3>
<p>Since data written to a Minipass stream is immediately written all the way through the pipeline, and <code>write()</code> always returns true/false based on whether the data was fully flushed, backpressure is communicated immediately to the upstream caller. This minimizes buffering.</p>
<p>Consider this case:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">const</span> <span class="op">{</span>PassThrough<span class="op">}</span> <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">const</span> p1 <span class="op">=</span> <span class="kw">new</span> <span class="at">PassThrough</span>(<span class="op">{</span> <span class="dt">highWaterMark</span><span class="op">:</span> <span class="dv">1024</span> <span class="op">}</span>)</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">const</span> p2 <span class="op">=</span> <span class="kw">new</span> <span class="at">PassThrough</span>(<span class="op">{</span> <span class="dt">highWaterMark</span><span class="op">:</span> <span class="dv">1024</span> <span class="op">}</span>)</a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">const</span> p3 <span class="op">=</span> <span class="kw">new</span> <span class="at">PassThrough</span>(<span class="op">{</span> <span class="dt">highWaterMark</span><span class="op">:</span> <span class="dv">1024</span> <span class="op">}</span>)</a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">const</span> p4 <span class="op">=</span> <span class="kw">new</span> <span class="at">PassThrough</span>(<span class="op">{</span> <span class="dt">highWaterMark</span><span class="op">:</span> <span class="dv">1024</span> <span class="op">}</span>)</a>
<a class="sourceLine" id="cb1-6" title="6"></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="va">p1</span>.<span class="at">pipe</span>(p2).<span class="at">pipe</span>(p3).<span class="at">pipe</span>(p4)</a>
<a class="sourceLine" id="cb1-8" title="8"><span class="va">p4</span>.<span class="at">on</span>(<span class="st">&#39;data&#39;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;made it through&#39;</span>))</a>
<a class="sourceLine" id="cb1-9" title="9"></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="co">// this returns false and buffers, then writes to p2 on next tick (1)</span></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="co">// p2 returns false and buffers, pausing p1, then writes to p3 on next tick (2)</span></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="co">// p3 returns false and buffers, pausing p2, then writes to p4 on next tick (3)</span></a>
<a class="sourceLine" id="cb1-13" title="13"><span class="co">// p4 returns false and buffers, pausing p3, then emits &#39;data&#39; and &#39;drain&#39;</span></a>
<a class="sourceLine" id="cb1-14" title="14"><span class="co">// on next tick (4)</span></a>
<a class="sourceLine" id="cb1-15" title="15"><span class="co">// p3 sees p4&#39;s &#39;drain&#39; event, and calls resume(), emitting &#39;resume&#39; and</span></a>
<a class="sourceLine" id="cb1-16" title="16"><span class="co">// &#39;drain&#39; on next tick (5)</span></a>
<a class="sourceLine" id="cb1-17" title="17"><span class="co">// p2 sees p3&#39;s &#39;drain&#39;, calls resume(), emits &#39;resume&#39; and &#39;drain&#39; on next tick (6)</span></a>
<a class="sourceLine" id="cb1-18" title="18"><span class="co">// p1 sees p2&#39;s &#39;drain&#39;, calls resume(), emits &#39;resume&#39; and &#39;drain&#39; on next</span></a>
<a class="sourceLine" id="cb1-19" title="19"><span class="co">// tick (7)</span></a>
<a class="sourceLine" id="cb1-20" title="20"></a>
<a class="sourceLine" id="cb1-21" title="21"><span class="va">p1</span>.<span class="at">write</span>(<span class="va">Buffer</span>.<span class="at">alloc</span>(<span class="dv">2048</span>)) <span class="co">// returns false</span></a></code></pre></div>
<p>Along the way, the data was buffered and deferred at each stage, and multiple event deferrals happened, for an unblocked pipeline where it was perfectly safe to write all the way through!</p>
<p>Furthermore, setting a <code>highWaterMark</code> of <code>1024</code> might lead someone reading the code to think an advisory maximum of 1KiB is being set for the pipeline. However, the actual advisory buffering level is the <em>sum</em> of <code>highWaterMark</code> values, since each one has its own bucket.</p>
<p>Consider the Minipass case:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">const</span> m1 <span class="op">=</span> <span class="kw">new</span> <span class="at">Minipass</span>()</a>
<a class="sourceLine" id="cb2-2" title="2"><span class="kw">const</span> m2 <span class="op">=</span> <span class="kw">new</span> <span class="at">Minipass</span>()</a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">const</span> m3 <span class="op">=</span> <span class="kw">new</span> <span class="at">Minipass</span>()</a>
<a class="sourceLine" id="cb2-4" title="4"><span class="kw">const</span> m4 <span class="op">=</span> <span class="kw">new</span> <span class="at">Minipass</span>()</a>
<a class="sourceLine" id="cb2-5" title="5"></a>
<a class="sourceLine" id="cb2-6" title="6"><span class="va">m1</span>.<span class="at">pipe</span>(m2).<span class="at">pipe</span>(m3).<span class="at">pipe</span>(m4)</a>
<a class="sourceLine" id="cb2-7" title="7"><span class="va">m4</span>.<span class="at">on</span>(<span class="st">&#39;data&#39;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;made it through&#39;</span>))</a>
<a class="sourceLine" id="cb2-8" title="8"></a>
<a class="sourceLine" id="cb2-9" title="9"><span class="co">// m1 is flowing, so it writes the data to m2 immediately</span></a>
<a class="sourceLine" id="cb2-10" title="10"><span class="co">// m2 is flowing, so it writes the data to m3 immediately</span></a>
<a class="sourceLine" id="cb2-11" title="11"><span class="co">// m3 is flowing, so it writes the data to m4 immediately</span></a>
<a class="sourceLine" id="cb2-12" title="12"><span class="co">// m4 is flowing, so it fires the &#39;data&#39; event immediately, returns true</span></a>
<a class="sourceLine" id="cb2-13" title="13"><span class="co">// m4&#39;s write returned true, so m3 is still flowing, returns true</span></a>
<a class="sourceLine" id="cb2-14" title="14"><span class="co">// m3&#39;s write returned true, so m2 is still flowing, returns true</span></a>
<a class="sourceLine" id="cb2-15" title="15"><span class="co">// m2&#39;s write returned true, so m1 is still flowing, returns true</span></a>
<a class="sourceLine" id="cb2-16" title="16"><span class="co">// No event deferrals or buffering along the way!</span></a>
<a class="sourceLine" id="cb2-17" title="17"></a>
<a class="sourceLine" id="cb2-18" title="18"><span class="va">m1</span>.<span class="at">write</span>(<span class="va">Buffer</span>.<span class="at">alloc</span>(<span class="dv">2048</span>)) <span class="co">// returns true</span></a></code></pre></div>
<p>It is extremely unlikely that you <em>don’t</em> want to buffer any data written, or <em>ever</em> buffer data that can be flushed all the way through. Neither node-core streams nor Minipass ever fail to buffer written data, but node-core streams do a lot of unnecessary buffering and pausing.</p>
<p>As always, the faster implementation is the one that does less stuff and waits less time to do it.</p>
<h3 id="immediately-emit-end-for-empty-streams-when-not-paused">Immediately emit <code>end</code> for empty streams (when not paused)</h3>
<p>If a stream is not paused, and <code>end()</code> is called before writing any data into it, then it will emit <code>end</code> immediately.</p>
<p>If you have logic that occurs on the <code>end</code> event which you don’t want to potentially happen immediately (for example, closing file descriptors, moving on to the next entry in an archive parse stream, etc.) then be sure to call <code>stream.pause()</code> on creation, and then <code>stream.resume()</code> once you are ready to respond to the <code>end</code> event.</p>
<h3 id="emit-end-when-asked">Emit <code>end</code> When Asked</h3>
<p>One hazard of immediately emitting <code>'end'</code> is that you may not yet have had a chance to add a listener. In order to avoid this hazard, Minipass streams safely re-emit the <code>'end'</code> event if a new listener is added after <code>'end'</code> has been emitted.</p>
<p>Ie, if you do <code>stream.on('end', someFunction)</code>, and the stream has already emitted <code>end</code>, then it will call the handler right away. (You can think of this somewhat like attaching a new <code>.then(fn)</code> to a previously-resolved Promise.)</p>
<p>To prevent calling handlers multiple times who would not expect multiple ends to occur, all listeners are removed from the <code>'end'</code> event whenever it is emitted.</p>
<h3 id="impact-of-immediate-flow-on-tee-streams">Impact of “immediate flow” on Tee-streams</h3>
<p>A “tee stream” is a stream piping to multiple destinations:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">const</span> tee <span class="op">=</span> <span class="kw">new</span> <span class="at">Minipass</span>()</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="va">t</span>.<span class="at">pipe</span>(dest1)</a>
<a class="sourceLine" id="cb3-3" title="3"><span class="va">t</span>.<span class="at">pipe</span>(dest2)</a>
<a class="sourceLine" id="cb3-4" title="4"><span class="va">t</span>.<span class="at">write</span>(<span class="st">&#39;foo&#39;</span>) <span class="co">// goes to both destinations</span></a></code></pre></div>
<p>Since Minipass streams <em>immediately</em> process any pending data through the pipeline when a new pipe destination is added, this can have surprising effects, especially when a stream comes in from some other function and may or may not have data in its buffer.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="co">// </span><span class="al">WARNING</span><span class="co">! WILL LOSE DATA!</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">const</span> src <span class="op">=</span> <span class="kw">new</span> <span class="at">Minipass</span>()</a>
<a class="sourceLine" id="cb4-3" title="3"><span class="va">src</span>.<span class="at">write</span>(<span class="st">&#39;foo&#39;</span>)</a>
<a class="sourceLine" id="cb4-4" title="4"><span class="va">src</span>.<span class="at">pipe</span>(dest1) <span class="co">// &#39;foo&#39; chunk flows to dest1 immediately, and is gone</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="va">src</span>.<span class="at">pipe</span>(dest2) <span class="co">// gets nothing!</span></a></code></pre></div>
<p>The solution is to create a dedicated tee-stream junction that pipes to both locations, and then pipe to <em>that</em> instead.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" title="1"><span class="co">// Safe example: tee to both places</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="kw">const</span> src <span class="op">=</span> <span class="kw">new</span> <span class="at">Minipass</span>()</a>
<a class="sourceLine" id="cb5-3" title="3"><span class="va">src</span>.<span class="at">write</span>(<span class="st">&#39;foo&#39;</span>)</a>
<a class="sourceLine" id="cb5-4" title="4"><span class="kw">const</span> tee <span class="op">=</span> <span class="kw">new</span> <span class="at">Minipass</span>()</a>
<a class="sourceLine" id="cb5-5" title="5"><span class="va">tee</span>.<span class="at">pipe</span>(dest1)</a>
<a class="sourceLine" id="cb5-6" title="6"><span class="va">tee</span>.<span class="at">pipe</span>(dest2)</a>
<a class="sourceLine" id="cb5-7" title="7"><span class="va">stream</span>.<span class="at">pipe</span>(tee) <span class="co">// tee gets &#39;foo&#39;, pipes to both locations</span></a></code></pre></div>
<p>The same caveat applies to <code>on('data')</code> event listeners. The first one added will <em>immediately</em> receive all of the data, leaving nothing for the second:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" title="1"><span class="co">// </span><span class="al">WARNING</span><span class="co">! WILL LOSE DATA!</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="kw">const</span> src <span class="op">=</span> <span class="kw">new</span> <span class="at">Minipass</span>()</a>
<a class="sourceLine" id="cb6-3" title="3"><span class="va">src</span>.<span class="at">write</span>(<span class="st">&#39;foo&#39;</span>)</a>
<a class="sourceLine" id="cb6-4" title="4"><span class="va">src</span>.<span class="at">on</span>(<span class="st">&#39;data&#39;</span><span class="op">,</span> handler1) <span class="co">// receives &#39;foo&#39; right away</span></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="va">src</span>.<span class="at">on</span>(<span class="st">&#39;data&#39;</span><span class="op">,</span> handler2) <span class="co">// nothing to see here!</span></a></code></pre></div>
<p>Using a dedicated tee-stream can be used in this case as well:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" title="1"><span class="co">// Safe example: tee to both data handlers</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="kw">const</span> src <span class="op">=</span> <span class="kw">new</span> <span class="at">Minipass</span>()</a>
<a class="sourceLine" id="cb7-3" title="3"><span class="va">src</span>.<span class="at">write</span>(<span class="st">&#39;foo&#39;</span>)</a>
<a class="sourceLine" id="cb7-4" title="4"><span class="kw">const</span> tee <span class="op">=</span> <span class="kw">new</span> <span class="at">Minipass</span>()</a>
<a class="sourceLine" id="cb7-5" title="5"><span class="va">tee</span>.<span class="at">on</span>(<span class="st">&#39;data&#39;</span><span class="op">,</span> handler1)</a>
<a class="sourceLine" id="cb7-6" title="6"><span class="va">tee</span>.<span class="at">on</span>(<span class="st">&#39;data&#39;</span><span class="op">,</span> handler2)</a>
<a class="sourceLine" id="cb7-7" title="7"><span class="va">src</span>.<span class="at">pipe</span>(tee)</a></code></pre></div>
<h2 id="usage">USAGE</h2>
<p>It’s a stream! Use it like a stream and it’ll most likely do what you want.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">const</span> Minipass <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;minipass&#39;</span>)</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="kw">const</span> mp <span class="op">=</span> <span class="kw">new</span> <span class="at">Minipass</span>(options) <span class="co">// optional: { encoding, objectMode }</span></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="va">mp</span>.<span class="at">write</span>(<span class="st">&#39;foo&#39;</span>)</a>
<a class="sourceLine" id="cb8-4" title="4"><span class="va">mp</span>.<span class="at">pipe</span>(someOtherStream)</a>
<a class="sourceLine" id="cb8-5" title="5"><span class="va">mp</span>.<span class="at">end</span>(<span class="st">&#39;bar&#39;</span>)</a></code></pre></div>
<h3 id="options">OPTIONS</h3>
<ul>
<li><code>encoding</code> How would you like the data coming <em>out</em> of the stream to be encoded? Accepts any values that can be passed to <code>Buffer.toString()</code>.</li>
<li><code>objectMode</code> Emit data exactly as it comes in. This will be flipped on by default if you write() something other than a string or Buffer at any point. Setting <code>objectMode: true</code> will prevent setting any encoding value.</li>
</ul>
<h3 id="api">API</h3>
<p>Implements the user-facing portions of Node.js’s <code>Readable</code> and <code>Writable</code> streams.</p>
<h3 id="methods">Methods</h3>
<ul>
<li><code>write(chunk, [encoding], [callback])</code> - Put data in. (Note that, in the base Minipass class, the same data will come out.) Returns <code>false</code> if the stream will buffer the next write, or true if it’s still in “flowing” mode.</li>
<li><code>end([chunk, [encoding]], [callback])</code> - Signal that you have no more data to write. This will queue an <code>end</code> event to be fired when all the data has been consumed.</li>
<li><code>setEncoding(encoding)</code> - Set the encoding for data coming of the stream. This can only be done once.</li>
<li><code>pause()</code> - No more data for a while, please. This also prevents <code>end</code> from being emitted for empty streams until the stream is resumed.</li>
<li><code>resume()</code> - Resume the stream. If there’s data in the buffer, it is all discarded. Any buffered events are immediately emitted.</li>
<li><code>pipe(dest)</code> - Send all output to the stream provided. There is no way to unpipe. When data is emitted, it is immediately written to any and all pipe destinations.</li>
<li><code>on(ev, fn)</code>, <code>emit(ev, fn)</code> - Minipass streams are EventEmitters. Some events are given special treatment, however. (See below under “events”.)</li>
<li><code>promise()</code> - Returns a Promise that resolves when the stream emits <code>end</code>, or rejects if the stream emits <code>error</code>.</li>
<li><code>collect()</code> - Return a Promise that resolves on <code>end</code> with an array containing each chunk of data that was emitted, or rejects if the stream emits <code>error</code>. Note that this consumes the stream data.</li>
<li><code>concat()</code> - Same as <code>collect()</code>, but concatenates the data into a single Buffer object. Will reject the returned promise if the stream is in objectMode, or if it goes into objectMode by the end of the data.</li>
<li><code>read(n)</code> - Consume <code>n</code> bytes of data out of the buffer. If <code>n</code> is not provided, then consume all of it. If <code>n</code> bytes are not available, then it returns null. <strong>Note</strong> consuming streams in this way is less efficient, and can lead to unnecessary Buffer copying.</li>
<li><code>destroy([er])</code> - Destroy the stream. If an error is provided, then an <code>'error'</code> event is emitted. If the stream has a <code>close()</code> method, and has not emitted a <code>'close'</code> event yet, then <code>stream.close()</code> will be called. Any Promises returned by <code>.promise()</code>, <code>.collect()</code> or <code>.concat()</code> will be rejected. After being destroyed, writing to the stream will emit an error. No more data will be emitted if the stream is destroyed, even if it was previously buffered.</li>
</ul>
<h3 id="properties">Properties</h3>
<ul>
<li><code>bufferLength</code> Read-only. Total number of bytes buffered, or in the case of objectMode, the total number of objects.</li>
<li><code>encoding</code> The encoding that has been set. (Setting this is equivalent to calling <code>setEncoding(enc)</code> and has the same prohibition against setting multiple times.)</li>
<li><code>flowing</code> Read-only. Boolean indicating whether a chunk written to the stream will be immediately emitted.</li>
<li><code>emittedEnd</code> Read-only. Boolean indicating whether the end-ish events (ie, <code>end</code>, <code>prefinish</code>, <code>finish</code>) have been emitted. Note that listening on any end-ish event will immediateyl re-emit it if it has already been emitted.</li>
<li><code>writable</code> Whether the stream is writable. Default <code>true</code>. Set to <code>false</code> when <code>end()</code></li>
<li><code>readable</code> Whether the stream is readable. Default <code>true</code>.</li>
<li><code>buffer</code> A <a href="http://npm.im/yallist">yallist</a> linked list of chunks written to the stream that have not yet been emitted. (It’s probably a bad idea to mess with this.)</li>
<li><code>pipes</code> A <a href="http://npm.im/yallist">yallist</a> linked list of streams that this stream is piping into. (It’s probably a bad idea to mess with this.)</li>
<li><code>destroyed</code> A getter that indicates whether the stream was destroyed.</li>
<li><code>paused</code> True if the stream has been explicitly paused, otherwise false.</li>
<li><code>objectMode</code> Indicates whether the stream is in <code>objectMode</code>. Once set to <code>true</code>, it cannot be set to <code>false</code>.</li>
</ul>
<h3 id="events">Events</h3>
<ul>
<li><code>data</code> Emitted when there’s data to read. Argument is the data to read. This is never emitted while not flowing. If a listener is attached, that will resume the stream.</li>
<li><code>end</code> Emitted when there’s no more data to read. This will be emitted immediately for empty streams when <code>end()</code> is called. If a listener is attached, and <code>end</code> was already emitted, then it will be emitted again. All listeners are removed when <code>end</code> is emitted.</li>
<li><code>prefinish</code> An end-ish event that follows the same logic as <code>end</code> and is emitted in the same conditions where <code>end</code> is emitted. Emitted after <code>'end'</code>.</li>
<li><code>finish</code> An end-ish event that follows the same logic as <code>end</code> and is emitted in the same conditions where <code>end</code> is emitted. Emitted after <code>'prefinish'</code>.</li>
<li><code>close</code> An indication that an underlying resource has been released. Minipass does not emit this event, but will defer it until after <code>end</code> has been emitted, since it throws off some stream libraries otherwise.</li>
<li><code>drain</code> Emitted when the internal buffer empties, and it is again suitable to <code>write()</code> into the stream.</li>
<li><code>readable</code> Emitted when data is buffered and ready to be read by a consumer.</li>
<li><code>resume</code> Emitted when stream changes state from buffering to flowing mode. (Ie, when <code>resume</code> is called, <code>pipe</code> is called, or a <code>data</code> event listener is added.)</li>
</ul>
<h3 id="static-methods">Static Methods</h3>
<ul>
<li><code>Minipass.isStream(stream)</code> Returns <code>true</code> if the argument is a stream, and false otherwise. To be considered a stream, the object must be either an instance of Minipass, or an EventEmitter that has either a <code>pipe()</code> method, or both <code>write()</code> and <code>end()</code> methods. (Pretty much any stream in node-land will return <code>true</code> for this.)</li>
</ul>
<h2 id="examples">EXAMPLES</h2>
<p>Here are some examples of things you can do with Minipass streams.</p>
<h3 id="simple-are-you-done-yet-promise">simple “are you done yet” promise</h3>
<div class="sourceCode" id="cb9"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb9-1" title="1"><span class="va">mp</span>.<span class="at">promise</span>().<span class="at">then</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb9-2" title="2">  <span class="co">// stream is finished</span></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="op">},</span> er <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb9-4" title="4">  <span class="co">// stream emitted an error</span></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="op">}</span>)</a></code></pre></div>
<h3 id="collecting">collecting</h3>
<div class="sourceCode" id="cb10"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb10-1" title="1"><span class="va">mp</span>.<span class="at">collect</span>().<span class="at">then</span>(all <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb10-2" title="2">  <span class="co">// all is an array of all the data emitted</span></a>
<a class="sourceLine" id="cb10-3" title="3">  <span class="co">// encoding is supported in this case, so</span></a>
<a class="sourceLine" id="cb10-4" title="4">  <span class="co">// so the result will be a collection of strings if</span></a>
<a class="sourceLine" id="cb10-5" title="5">  <span class="co">// an encoding is specified, or buffers/objects if not.</span></a>
<a class="sourceLine" id="cb10-6" title="6">  <span class="co">//</span></a>
<a class="sourceLine" id="cb10-7" title="7">  <span class="co">// In an async function, you may do</span></a>
<a class="sourceLine" id="cb10-8" title="8">  <span class="co">// const data = await stream.collect()</span></a>
<a class="sourceLine" id="cb10-9" title="9"><span class="op">}</span>)</a></code></pre></div>
<h3 id="collecting-into-a-single-blob">collecting into a single blob</h3>
<p>This is a bit slower because it concatenates the data into one chunk for you, but if you’re going to do it yourself anyway, it’s convenient this way:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb11-1" title="1"><span class="va">mp</span>.<span class="at">concat</span>().<span class="at">then</span>(onebigchunk <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb11-2" title="2">  <span class="co">// onebigchunk is a string if the stream</span></a>
<a class="sourceLine" id="cb11-3" title="3">  <span class="co">// had an encoding set, or a buffer otherwise.</span></a>
<a class="sourceLine" id="cb11-4" title="4"><span class="op">}</span>)</a></code></pre></div>
<h3 id="iteration">iteration</h3>
<p>You can iterate over streams synchronously or asynchronously in platforms that support it.</p>
<p>Synchronous iteration will end when the currently available data is consumed, even if the <code>end</code> event has not been reached. In string and buffer mode, the data is concatenated, so unless multiple writes are occurring in the same tick as the <code>read()</code>, sync iteration loops will generally only have a single iteration.</p>
<p>To consume chunks in this way exactly as they have been written, with no flattening, create the stream with the <code>{ objectMode: true }</code> option.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">const</span> mp <span class="op">=</span> <span class="kw">new</span> <span class="at">Minipass</span>(<span class="op">{</span> <span class="dt">objectMode</span><span class="op">:</span> <span class="kw">true</span> <span class="op">}</span>)</a>
<a class="sourceLine" id="cb12-2" title="2"><span class="va">mp</span>.<span class="at">write</span>(<span class="st">&#39;a&#39;</span>)</a>
<a class="sourceLine" id="cb12-3" title="3"><span class="va">mp</span>.<span class="at">write</span>(<span class="st">&#39;b&#39;</span>)</a>
<a class="sourceLine" id="cb12-4" title="4"><span class="cf">for</span> (<span class="kw">let</span> letter <span class="kw">of</span> mp) <span class="op">{</span></a>
<a class="sourceLine" id="cb12-5" title="5">  <span class="va">console</span>.<span class="at">log</span>(letter) <span class="co">// a, b</span></a>
<a class="sourceLine" id="cb12-6" title="6"><span class="op">}</span></a>
<a class="sourceLine" id="cb12-7" title="7"><span class="va">mp</span>.<span class="at">write</span>(<span class="st">&#39;c&#39;</span>)</a>
<a class="sourceLine" id="cb12-8" title="8"><span class="va">mp</span>.<span class="at">write</span>(<span class="st">&#39;d&#39;</span>)</a>
<a class="sourceLine" id="cb12-9" title="9"><span class="cf">for</span> (<span class="kw">let</span> letter <span class="kw">of</span> mp) <span class="op">{</span></a>
<a class="sourceLine" id="cb12-10" title="10">  <span class="va">console</span>.<span class="at">log</span>(letter) <span class="co">// c, d</span></a>
<a class="sourceLine" id="cb12-11" title="11"><span class="op">}</span></a>
<a class="sourceLine" id="cb12-12" title="12"><span class="va">mp</span>.<span class="at">write</span>(<span class="st">&#39;e&#39;</span>)</a>
<a class="sourceLine" id="cb12-13" title="13"><span class="va">mp</span>.<span class="at">end</span>()</a>
<a class="sourceLine" id="cb12-14" title="14"><span class="cf">for</span> (<span class="kw">let</span> letter <span class="kw">of</span> mp) <span class="op">{</span></a>
<a class="sourceLine" id="cb12-15" title="15">  <span class="va">console</span>.<span class="at">log</span>(letter) <span class="co">// e</span></a>
<a class="sourceLine" id="cb12-16" title="16"><span class="op">}</span></a>
<a class="sourceLine" id="cb12-17" title="17"><span class="cf">for</span> (<span class="kw">let</span> letter <span class="kw">of</span> mp) <span class="op">{</span></a>
<a class="sourceLine" id="cb12-18" title="18">  <span class="va">console</span>.<span class="at">log</span>(letter) <span class="co">// nothing</span></a>
<a class="sourceLine" id="cb12-19" title="19"><span class="op">}</span></a></code></pre></div>
<p>Asynchronous iteration will continue until the end event is reached, consuming all of the data.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">const</span> mp <span class="op">=</span> <span class="kw">new</span> <span class="at">Minipass</span>(<span class="op">{</span> <span class="dt">encoding</span><span class="op">:</span> <span class="st">&#39;utf8&#39;</span> <span class="op">}</span>)</a>
<a class="sourceLine" id="cb13-2" title="2"></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="co">// some source of some data</span></a>
<a class="sourceLine" id="cb13-4" title="4"><span class="kw">let</span> i <span class="op">=</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb13-5" title="5"><span class="kw">const</span> inter <span class="op">=</span> <span class="at">setInterval</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb13-6" title="6">  <span class="cf">if</span> (i <span class="op">--&gt;</span> <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb13-7" title="7">    <span class="va">mp</span>.<span class="at">write</span>(<span class="va">Buffer</span>.<span class="at">from</span>(<span class="st">&#39;foo</span><span class="sc">\n</span><span class="st">&#39;</span><span class="op">,</span> <span class="st">&#39;utf8&#39;</span>))</a>
<a class="sourceLine" id="cb13-8" title="8">  <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb13-9" title="9">    <span class="va">mp</span>.<span class="at">end</span>()</a>
<a class="sourceLine" id="cb13-10" title="10">    <span class="at">clearInterval</span>(inter)</a>
<a class="sourceLine" id="cb13-11" title="11">  <span class="op">}</span></a>
<a class="sourceLine" id="cb13-12" title="12"><span class="op">},</span> <span class="dv">100</span>)</a>
<a class="sourceLine" id="cb13-13" title="13"></a>
<a class="sourceLine" id="cb13-14" title="14"><span class="co">// consume the data with asynchronous iteration</span></a>
<a class="sourceLine" id="cb13-15" title="15"><span class="kw">async</span> <span class="kw">function</span> <span class="at">consume</span> () <span class="op">{</span></a>
<a class="sourceLine" id="cb13-16" title="16">  <span class="cf">for</span> <span class="cf">await</span> (<span class="kw">let</span> chunk <span class="kw">of</span> mp) <span class="op">{</span></a>
<a class="sourceLine" id="cb13-17" title="17">    <span class="va">console</span>.<span class="at">log</span>(chunk)</a>
<a class="sourceLine" id="cb13-18" title="18">  <span class="op">}</span></a>
<a class="sourceLine" id="cb13-19" title="19">  <span class="cf">return</span> <span class="st">&#39;ok&#39;</span></a>
<a class="sourceLine" id="cb13-20" title="20"><span class="op">}</span></a>
<a class="sourceLine" id="cb13-21" title="21"></a>
<a class="sourceLine" id="cb13-22" title="22"><span class="at">consume</span>().<span class="at">then</span>(res <span class="kw">=&gt;</span> <span class="va">console</span>.<span class="at">log</span>(res))</a>
<a class="sourceLine" id="cb13-23" title="23"><span class="co">// logs `foo\n` 5 times, and then `ok`</span></a></code></pre></div>
<h3 id="subclass-that-console.logs-everything-written-into-it">subclass that <code>console.log()</code>s everything written into it</h3>
<div class="sourceCode" id="cb14"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">class</span> Logger <span class="kw">extends</span> Minipass <span class="op">{</span></a>
<a class="sourceLine" id="cb14-2" title="2">  <span class="at">write</span> (chunk<span class="op">,</span> encoding<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb14-3" title="3">    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;WRITE&#39;</span><span class="op">,</span> chunk<span class="op">,</span> encoding)</a>
<a class="sourceLine" id="cb14-4" title="4">    <span class="cf">return</span> <span class="kw">super</span>.<span class="at">write</span>(chunk<span class="op">,</span> encoding<span class="op">,</span> callback)</a>
<a class="sourceLine" id="cb14-5" title="5">  <span class="op">}</span></a>
<a class="sourceLine" id="cb14-6" title="6">  <span class="at">end</span> (chunk<span class="op">,</span> encoding<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb14-7" title="7">    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;END&#39;</span><span class="op">,</span> chunk<span class="op">,</span> encoding)</a>
<a class="sourceLine" id="cb14-8" title="8">    <span class="cf">return</span> <span class="kw">super</span>.<span class="at">end</span>(chunk<span class="op">,</span> encoding<span class="op">,</span> callback)</a>
<a class="sourceLine" id="cb14-9" title="9">  <span class="op">}</span></a>
<a class="sourceLine" id="cb14-10" title="10"><span class="op">}</span></a>
<a class="sourceLine" id="cb14-11" title="11"></a>
<a class="sourceLine" id="cb14-12" title="12"><span class="va">someSource</span>.<span class="at">pipe</span>(<span class="kw">new</span> <span class="at">Logger</span>()).<span class="at">pipe</span>(someDest)</a></code></pre></div>
<h3 id="same-thing-but-using-an-inline-anonymous-class">same thing, but using an inline anonymous class</h3>
<div class="sourceCode" id="cb15"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb15-1" title="1"><span class="co">// js classes are fun</span></a>
<a class="sourceLine" id="cb15-2" title="2">someSource</a>
<a class="sourceLine" id="cb15-3" title="3">  .<span class="at">pipe</span>(<span class="kw">new</span> (<span class="kw">class</span> <span class="kw">extends</span> Minipass <span class="op">{</span></a>
<a class="sourceLine" id="cb15-4" title="4">    <span class="at">emit</span> (ev<span class="op">,</span> ...<span class="at">data</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb15-5" title="5">      <span class="co">// let&#39;s also log events, because debugging some weird thing</span></a>
<a class="sourceLine" id="cb15-6" title="6">      <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;EMIT&#39;</span><span class="op">,</span> ev)</a>
<a class="sourceLine" id="cb15-7" title="7">      <span class="cf">return</span> <span class="kw">super</span>.<span class="at">emit</span>(ev<span class="op">,</span> ...<span class="at">data</span>)</a>
<a class="sourceLine" id="cb15-8" title="8">    <span class="op">}</span></a>
<a class="sourceLine" id="cb15-9" title="9">    <span class="at">write</span> (chunk<span class="op">,</span> encoding<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb15-10" title="10">      <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;WRITE&#39;</span><span class="op">,</span> chunk<span class="op">,</span> encoding)</a>
<a class="sourceLine" id="cb15-11" title="11">      <span class="cf">return</span> <span class="kw">super</span>.<span class="at">write</span>(chunk<span class="op">,</span> encoding<span class="op">,</span> callback)</a>
<a class="sourceLine" id="cb15-12" title="12">    <span class="op">}</span></a>
<a class="sourceLine" id="cb15-13" title="13">    <span class="at">end</span> (chunk<span class="op">,</span> encoding<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb15-14" title="14">      <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;END&#39;</span><span class="op">,</span> chunk<span class="op">,</span> encoding)</a>
<a class="sourceLine" id="cb15-15" title="15">      <span class="cf">return</span> <span class="kw">super</span>.<span class="at">end</span>(chunk<span class="op">,</span> encoding<span class="op">,</span> callback)</a>
<a class="sourceLine" id="cb15-16" title="16">    <span class="op">}</span></a>
<a class="sourceLine" id="cb15-17" title="17">  <span class="op">}</span>))</a>
<a class="sourceLine" id="cb15-18" title="18">  .<span class="at">pipe</span>(someDest)</a></code></pre></div>
<h3 id="subclass-that-defers-end-for-some-reason">subclass that defers ‘end’ for some reason</h3>
<div class="sourceCode" id="cb16"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">class</span> SlowEnd <span class="kw">extends</span> Minipass <span class="op">{</span></a>
<a class="sourceLine" id="cb16-2" title="2">  <span class="at">emit</span> (ev<span class="op">,</span> ...<span class="at">args</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb16-3" title="3">    <span class="cf">if</span> (ev <span class="op">===</span> <span class="st">&#39;end&#39;</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb16-4" title="4">      <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;going to end, hold on a sec&#39;</span>)</a>
<a class="sourceLine" id="cb16-5" title="5">      <span class="at">setTimeout</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb16-6" title="6">        <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;ok, ready to end now&#39;</span>)</a>
<a class="sourceLine" id="cb16-7" title="7">        <span class="kw">super</span>.<span class="at">emit</span>(<span class="st">&#39;end&#39;</span><span class="op">,</span> ...<span class="at">args</span>)</a>
<a class="sourceLine" id="cb16-8" title="8">      <span class="op">},</span> <span class="dv">100</span>)</a>
<a class="sourceLine" id="cb16-9" title="9">    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb16-10" title="10">      <span class="cf">return</span> <span class="kw">super</span>.<span class="at">emit</span>(ev<span class="op">,</span> ...<span class="at">args</span>)</a>
<a class="sourceLine" id="cb16-11" title="11">    <span class="op">}</span></a>
<a class="sourceLine" id="cb16-12" title="12">  <span class="op">}</span></a>
<a class="sourceLine" id="cb16-13" title="13"><span class="op">}</span></a></code></pre></div>
<h3 id="transform-that-creates-newline-delimited-json">transform that creates newline-delimited JSON</h3>
<div class="sourceCode" id="cb17"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">class</span> NDJSONEncode <span class="kw">extends</span> Minipass <span class="op">{</span></a>
<a class="sourceLine" id="cb17-2" title="2">  <span class="at">write</span> (obj<span class="op">,</span> cb) <span class="op">{</span></a>
<a class="sourceLine" id="cb17-3" title="3">    <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb17-4" title="4">      <span class="co">// JSON.stringify can throw, emit an error on that</span></a>
<a class="sourceLine" id="cb17-5" title="5">      <span class="cf">return</span> <span class="kw">super</span>.<span class="at">write</span>(<span class="va">JSON</span>.<span class="at">stringify</span>(obj) <span class="op">+</span> <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span><span class="op">,</span> <span class="st">&#39;utf8&#39;</span><span class="op">,</span> cb)</a>
<a class="sourceLine" id="cb17-6" title="6">    <span class="op">}</span> <span class="cf">catch</span> (er) <span class="op">{</span></a>
<a class="sourceLine" id="cb17-7" title="7">      <span class="kw">this</span>.<span class="at">emit</span>(<span class="st">&#39;error&#39;</span><span class="op">,</span> er)</a>
<a class="sourceLine" id="cb17-8" title="8">    <span class="op">}</span></a>
<a class="sourceLine" id="cb17-9" title="9">  <span class="op">}</span></a>
<a class="sourceLine" id="cb17-10" title="10">  <span class="at">end</span> (obj<span class="op">,</span> cb) <span class="op">{</span></a>
<a class="sourceLine" id="cb17-11" title="11">    <span class="cf">if</span> (<span class="kw">typeof</span> obj <span class="op">===</span> <span class="st">&#39;function&#39;</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb17-12" title="12">      cb <span class="op">=</span> obj</a>
<a class="sourceLine" id="cb17-13" title="13">      obj <span class="op">=</span> <span class="kw">undefined</span></a>
<a class="sourceLine" id="cb17-14" title="14">    <span class="op">}</span></a>
<a class="sourceLine" id="cb17-15" title="15">    <span class="cf">if</span> (obj <span class="op">!==</span> <span class="kw">undefined</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb17-16" title="16">      <span class="kw">this</span>.<span class="at">write</span>(obj)</a>
<a class="sourceLine" id="cb17-17" title="17">    <span class="op">}</span></a>
<a class="sourceLine" id="cb17-18" title="18">    <span class="cf">return</span> <span class="kw">super</span>.<span class="at">end</span>(cb)</a>
<a class="sourceLine" id="cb17-19" title="19">  <span class="op">}</span></a>
<a class="sourceLine" id="cb17-20" title="20"><span class="op">}</span></a></code></pre></div>
<h3 id="transform-that-parses-newline-delimited-json">transform that parses newline-delimited JSON</h3>
<div class="sourceCode" id="cb18"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">class</span> NDJSONDecode <span class="kw">extends</span> Minipass <span class="op">{</span></a>
<a class="sourceLine" id="cb18-2" title="2">  <span class="at">constructor</span> (options) <span class="op">{</span></a>
<a class="sourceLine" id="cb18-3" title="3">    <span class="co">// always be in object mode, as far as Minipass is concerned</span></a>
<a class="sourceLine" id="cb18-4" title="4">    <span class="kw">super</span>(<span class="op">{</span> <span class="dt">objectMode</span><span class="op">:</span> <span class="kw">true</span> <span class="op">}</span>)</a>
<a class="sourceLine" id="cb18-5" title="5">    <span class="kw">this</span>.<span class="at">_jsonBuffer</span> <span class="op">=</span> <span class="st">&#39;&#39;</span></a>
<a class="sourceLine" id="cb18-6" title="6">  <span class="op">}</span></a>
<a class="sourceLine" id="cb18-7" title="7">  <span class="at">write</span> (chunk<span class="op">,</span> encoding<span class="op">,</span> cb) <span class="op">{</span></a>
<a class="sourceLine" id="cb18-8" title="8">    <span class="cf">if</span> (<span class="kw">typeof</span> chunk <span class="op">===</span> <span class="st">&#39;string&#39;</span> <span class="op">&amp;&amp;</span></a>
<a class="sourceLine" id="cb18-9" title="9">        <span class="kw">typeof</span> encoding <span class="op">===</span> <span class="st">&#39;string&#39;</span> <span class="op">&amp;&amp;</span></a>
<a class="sourceLine" id="cb18-10" title="10">        encoding <span class="op">!==</span> <span class="st">&#39;utf8&#39;</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb18-11" title="11">      chunk <span class="op">=</span> <span class="va">Buffer</span>.<span class="at">from</span>(chunk<span class="op">,</span> encoding).<span class="at">toString</span>()</a>
<a class="sourceLine" id="cb18-12" title="12">    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (<span class="va">Buffer</span>.<span class="at">isBuffer</span>(chunk))</a>
<a class="sourceLine" id="cb18-13" title="13">      chunk <span class="op">=</span> <span class="va">chunk</span>.<span class="at">toString</span>()</a>
<a class="sourceLine" id="cb18-14" title="14">    <span class="op">}</span></a>
<a class="sourceLine" id="cb18-15" title="15">    <span class="cf">if</span> (<span class="kw">typeof</span> encoding <span class="op">===</span> <span class="st">&#39;function&#39;</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb18-16" title="16">      cb <span class="op">=</span> encoding</a>
<a class="sourceLine" id="cb18-17" title="17">    <span class="op">}</span></a>
<a class="sourceLine" id="cb18-18" title="18">    <span class="kw">const</span> jsonData <span class="op">=</span> (<span class="kw">this</span>.<span class="at">_jsonBuffer</span> <span class="op">+</span> chunk).<span class="at">split</span>(<span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span>)</a>
<a class="sourceLine" id="cb18-19" title="19">    <span class="kw">this</span>.<span class="at">_jsonBuffer</span> <span class="op">=</span> <span class="va">jsonData</span>.<span class="at">pop</span>()</a>
<a class="sourceLine" id="cb18-20" title="20">    <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">jsonData</span>.<span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb18-21" title="21">      <span class="kw">let</span> parsed</a>
<a class="sourceLine" id="cb18-22" title="22">      <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb18-23" title="23">        <span class="kw">super</span>.<span class="at">write</span>(parsed)</a>
<a class="sourceLine" id="cb18-24" title="24">      <span class="op">}</span> <span class="cf">catch</span> (er) <span class="op">{</span></a>
<a class="sourceLine" id="cb18-25" title="25">        <span class="kw">this</span>.<span class="at">emit</span>(<span class="st">&#39;error&#39;</span><span class="op">,</span> er)</a>
<a class="sourceLine" id="cb18-26" title="26">        <span class="cf">continue</span></a>
<a class="sourceLine" id="cb18-27" title="27">      <span class="op">}</span></a>
<a class="sourceLine" id="cb18-28" title="28">    <span class="op">}</span></a>
<a class="sourceLine" id="cb18-29" title="29">    <span class="cf">if</span> (cb)</a>
<a class="sourceLine" id="cb18-30" title="30">      <span class="at">cb</span>()</a>
<a class="sourceLine" id="cb18-31" title="31">  <span class="op">}</span></a>
<a class="sourceLine" id="cb18-32" title="32">}</a></code></pre></div>
</body>
</html>
